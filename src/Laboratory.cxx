// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Laboratory.hxx"

// RotationType
// 

const RotationType::Axis_type& RotationType::
Axis () const
{
  return this->Axis_.get ();
}

RotationType::Axis_type& RotationType::
Axis ()
{
  return this->Axis_.get ();
}

void RotationType::
Axis (const Axis_type& x)
{
  this->Axis_.set (x);
}

void RotationType::
Axis (::std::auto_ptr< Axis_type > x)
{
  this->Axis_.set (x);
}

const RotationType::Degrees_type& RotationType::
Degrees () const
{
  return this->Degrees_.get ();
}

RotationType::Degrees_type& RotationType::
Degrees ()
{
  return this->Degrees_.get ();
}

void RotationType::
Degrees (const Degrees_type& x)
{
  this->Degrees_.set (x);
}


// ForcePlateToGlobalRotations
// 

const ForcePlateToGlobalRotations::Rot_sequence& ForcePlateToGlobalRotations::
Rot () const
{
  return this->Rot_;
}

ForcePlateToGlobalRotations::Rot_sequence& ForcePlateToGlobalRotations::
Rot ()
{
  return this->Rot_;
}

void ForcePlateToGlobalRotations::
Rot (const Rot_sequence& s)
{
  this->Rot_ = s;
}


// ForcePlatformOrigin
// 

const ForcePlatformOrigin::x_type& ForcePlatformOrigin::
x () const
{
  return this->x_.get ();
}

ForcePlatformOrigin::x_type& ForcePlatformOrigin::
x ()
{
  return this->x_.get ();
}

void ForcePlatformOrigin::
x (const x_type& x)
{
  this->x_.set (x);
}

const ForcePlatformOrigin::y_type& ForcePlatformOrigin::
y () const
{
  return this->y_.get ();
}

ForcePlatformOrigin::y_type& ForcePlatformOrigin::
y ()
{
  return this->y_.get ();
}

void ForcePlatformOrigin::
y (const y_type& x)
{
  this->y_.set (x);
}

const ForcePlatformOrigin::z_type& ForcePlatformOrigin::
z () const
{
  return this->z_.get ();
}

ForcePlatformOrigin::z_type& ForcePlatformOrigin::
z ()
{
  return this->z_.get ();
}

void ForcePlatformOrigin::
z (const z_type& x)
{
  this->z_.set (x);
}


// ForcePlatformType
// 

const ForcePlatformType::ID_type& ForcePlatformType::
ID () const
{
  return this->ID_.get ();
}

ForcePlatformType::ID_type& ForcePlatformType::
ID ()
{
  return this->ID_.get ();
}

void ForcePlatformType::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

const ForcePlatformType::Brand_type& ForcePlatformType::
Brand () const
{
  return this->Brand_.get ();
}

ForcePlatformType::Brand_type& ForcePlatformType::
Brand ()
{
  return this->Brand_.get ();
}

void ForcePlatformType::
Brand (const Brand_type& x)
{
  this->Brand_.set (x);
}

void ForcePlatformType::
Brand (::std::auto_ptr< Brand_type > x)
{
  this->Brand_.set (x);
}

const ForcePlatformType::Type_type& ForcePlatformType::
Type () const
{
  return this->Type_.get ();
}

ForcePlatformType::Type_type& ForcePlatformType::
Type ()
{
  return this->Type_.get ();
}

void ForcePlatformType::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

const ForcePlatformType::FrameRate_type& ForcePlatformType::
FrameRate () const
{
  return this->FrameRate_.get ();
}

ForcePlatformType::FrameRate_type& ForcePlatformType::
FrameRate ()
{
  return this->FrameRate_.get ();
}

void ForcePlatformType::
FrameRate (const FrameRate_type& x)
{
  this->FrameRate_.set (x);
}

const ForcePlatformType::FPtoGlobalRotations_type& ForcePlatformType::
FPtoGlobalRotations () const
{
  return this->FPtoGlobalRotations_.get ();
}

ForcePlatformType::FPtoGlobalRotations_type& ForcePlatformType::
FPtoGlobalRotations ()
{
  return this->FPtoGlobalRotations_.get ();
}

void ForcePlatformType::
FPtoGlobalRotations (const FPtoGlobalRotations_type& x)
{
  this->FPtoGlobalRotations_.set (x);
}

void ForcePlatformType::
FPtoGlobalRotations (::std::auto_ptr< FPtoGlobalRotations_type > x)
{
  this->FPtoGlobalRotations_.set (x);
}

const ForcePlatformType::origin_type& ForcePlatformType::
origin () const
{
  return this->origin_.get ();
}

ForcePlatformType::origin_type& ForcePlatformType::
origin ()
{
  return this->origin_.get ();
}

void ForcePlatformType::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void ForcePlatformType::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const ForcePlatformType::originGlobal_type& ForcePlatformType::
originGlobal () const
{
  return this->originGlobal_.get ();
}

ForcePlatformType::originGlobal_type& ForcePlatformType::
originGlobal ()
{
  return this->originGlobal_.get ();
}

void ForcePlatformType::
originGlobal (const originGlobal_type& x)
{
  this->originGlobal_.set (x);
}

void ForcePlatformType::
originGlobal (::std::auto_ptr< originGlobal_type > x)
{
  this->originGlobal_.set (x);
}


// ForcePlatformsType
// 

const ForcePlatformsType::ForcePlatform_sequence& ForcePlatformsType::
ForcePlatform () const
{
  return this->ForcePlatform_;
}

ForcePlatformsType::ForcePlatform_sequence& ForcePlatformsType::
ForcePlatform ()
{
  return this->ForcePlatform_;
}

void ForcePlatformsType::
ForcePlatform (const ForcePlatform_sequence& s)
{
  this->ForcePlatform_ = s;
}


// LaboratoryType
// 

const LaboratoryType::Name_type& LaboratoryType::
Name () const
{
  return this->Name_.get ();
}

LaboratoryType::Name_type& LaboratoryType::
Name ()
{
  return this->Name_.get ();
}

void LaboratoryType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void LaboratoryType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const LaboratoryType::Name_type& LaboratoryType::
Name_default_value ()
{
  return Name_default_value_;
}

const LaboratoryType::MotionCaptureSystem_type& LaboratoryType::
MotionCaptureSystem () const
{
  return this->MotionCaptureSystem_.get ();
}

LaboratoryType::MotionCaptureSystem_type& LaboratoryType::
MotionCaptureSystem ()
{
  return this->MotionCaptureSystem_.get ();
}

void LaboratoryType::
MotionCaptureSystem (const MotionCaptureSystem_type& x)
{
  this->MotionCaptureSystem_.set (x);
}

void LaboratoryType::
MotionCaptureSystem (::std::auto_ptr< MotionCaptureSystem_type > x)
{
  this->MotionCaptureSystem_.set (x);
}

const LaboratoryType::CoordinateSystemOrientation_type& LaboratoryType::
CoordinateSystemOrientation () const
{
  return this->CoordinateSystemOrientation_.get ();
}

LaboratoryType::CoordinateSystemOrientation_type& LaboratoryType::
CoordinateSystemOrientation ()
{
  return this->CoordinateSystemOrientation_.get ();
}

void LaboratoryType::
CoordinateSystemOrientation (const CoordinateSystemOrientation_type& x)
{
  this->CoordinateSystemOrientation_.set (x);
}

void LaboratoryType::
CoordinateSystemOrientation (::std::auto_ptr< CoordinateSystemOrientation_type > x)
{
  this->CoordinateSystemOrientation_.set (x);
}

const LaboratoryType::NumberOfForcePlatforms_type& LaboratoryType::
NumberOfForcePlatforms () const
{
  return this->NumberOfForcePlatforms_.get ();
}

LaboratoryType::NumberOfForcePlatforms_type& LaboratoryType::
NumberOfForcePlatforms ()
{
  return this->NumberOfForcePlatforms_.get ();
}

void LaboratoryType::
NumberOfForcePlatforms (const NumberOfForcePlatforms_type& x)
{
  this->NumberOfForcePlatforms_.set (x);
}

const LaboratoryType::ForcePlatformsList_sequence& LaboratoryType::
ForcePlatformsList () const
{
  return this->ForcePlatformsList_;
}

LaboratoryType::ForcePlatformsList_sequence& LaboratoryType::
ForcePlatformsList ()
{
  return this->ForcePlatformsList_;
}

void LaboratoryType::
ForcePlatformsList (const ForcePlatformsList_sequence& s)
{
  this->ForcePlatformsList_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RotationType
//

RotationType::
RotationType (const Axis_type& Axis,
              const Degrees_type& Degrees)
: ::xml_schema::type (),
  Axis_ (Axis, this),
  Degrees_ (Degrees, this)
{
}

RotationType::
RotationType (const RotationType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Axis_ (x.Axis_, f, this),
  Degrees_ (x.Degrees_, f, this)
{
}

RotationType::
RotationType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Axis_ (this),
  Degrees_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotationType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Axis
    //
    if (n.name () == "Axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axis_type > r (
        Axis_traits::create (i, f, this));

      if (!Axis_.present ())
      {
        this->Axis_.set (r);
        continue;
      }
    }

    // Degrees
    //
    if (n.name () == "Degrees" && n.namespace_ ().empty ())
    {
      if (!Degrees_.present ())
      {
        this->Degrees_.set (Degrees_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Axis",
      "");
  }

  if (!Degrees_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Degrees",
      "");
  }
}

RotationType* RotationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotationType (*this, f, c);
}

RotationType& RotationType::
operator= (const RotationType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Axis_ = x.Axis_;
    this->Degrees_ = x.Degrees_;
  }

  return *this;
}

RotationType::
~RotationType ()
{
}

// ForcePlateToGlobalRotations
//

ForcePlateToGlobalRotations::
ForcePlateToGlobalRotations ()
: ::xml_schema::type (),
  Rot_ (this)
{
}

ForcePlateToGlobalRotations::
ForcePlateToGlobalRotations (const ForcePlateToGlobalRotations& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Rot_ (x.Rot_, f, this)
{
}

ForcePlateToGlobalRotations::
ForcePlateToGlobalRotations (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Rot_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ForcePlateToGlobalRotations::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Rot
    //
    if (n.name () == "Rot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Rot_type > r (
        Rot_traits::create (i, f, this));

      this->Rot_.push_back (r);
      continue;
    }

    break;
  }
}

ForcePlateToGlobalRotations* ForcePlateToGlobalRotations::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForcePlateToGlobalRotations (*this, f, c);
}

ForcePlateToGlobalRotations& ForcePlateToGlobalRotations::
operator= (const ForcePlateToGlobalRotations& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Rot_ = x.Rot_;
  }

  return *this;
}

ForcePlateToGlobalRotations::
~ForcePlateToGlobalRotations ()
{
}

// ForcePlatformOrigin
//

ForcePlatformOrigin::
ForcePlatformOrigin (const x_type& x,
                     const y_type& y,
                     const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

ForcePlatformOrigin::
ForcePlatformOrigin (const ForcePlatformOrigin& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

ForcePlatformOrigin::
ForcePlatformOrigin (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ForcePlatformOrigin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

ForcePlatformOrigin* ForcePlatformOrigin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForcePlatformOrigin (*this, f, c);
}

ForcePlatformOrigin& ForcePlatformOrigin::
operator= (const ForcePlatformOrigin& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

ForcePlatformOrigin::
~ForcePlatformOrigin ()
{
}

// ForcePlatformType
//

ForcePlatformType::
ForcePlatformType (const ID_type& ID,
                   const Brand_type& Brand,
                   const Type_type& Type,
                   const FrameRate_type& FrameRate,
                   const FPtoGlobalRotations_type& FPtoGlobalRotations,
                   const origin_type& origin,
                   const originGlobal_type& originGlobal)
: ::xml_schema::type (),
  ID_ (ID, this),
  Brand_ (Brand, this),
  Type_ (Type, this),
  FrameRate_ (FrameRate, this),
  FPtoGlobalRotations_ (FPtoGlobalRotations, this),
  origin_ (origin, this),
  originGlobal_ (originGlobal, this)
{
}

ForcePlatformType::
ForcePlatformType (const ID_type& ID,
                   const Brand_type& Brand,
                   const Type_type& Type,
                   const FrameRate_type& FrameRate,
                   ::std::auto_ptr< FPtoGlobalRotations_type > FPtoGlobalRotations,
                   ::std::auto_ptr< origin_type > origin,
                   ::std::auto_ptr< originGlobal_type > originGlobal)
: ::xml_schema::type (),
  ID_ (ID, this),
  Brand_ (Brand, this),
  Type_ (Type, this),
  FrameRate_ (FrameRate, this),
  FPtoGlobalRotations_ (FPtoGlobalRotations, this),
  origin_ (origin, this),
  originGlobal_ (originGlobal, this)
{
}

ForcePlatformType::
ForcePlatformType (const ForcePlatformType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  Brand_ (x.Brand_, f, this),
  Type_ (x.Type_, f, this),
  FrameRate_ (x.FrameRate_, f, this),
  FPtoGlobalRotations_ (x.FPtoGlobalRotations_, f, this),
  origin_ (x.origin_, f, this),
  originGlobal_ (x.originGlobal_, f, this)
{
}

ForcePlatformType::
ForcePlatformType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  Brand_ (this),
  Type_ (this),
  FrameRate_ (this),
  FPtoGlobalRotations_ (this),
  origin_ (this),
  originGlobal_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ForcePlatformType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID
    //
    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      if (!ID_.present ())
      {
        this->ID_.set (ID_traits::create (i, f, this));
        continue;
      }
    }

    // Brand
    //
    if (n.name () == "Brand" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Brand_type > r (
        Brand_traits::create (i, f, this));

      if (!Brand_.present ())
      {
        this->Brand_.set (r);
        continue;
      }
    }

    // Type
    //
    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      if (!Type_.present ())
      {
        this->Type_.set (Type_traits::create (i, f, this));
        continue;
      }
    }

    // FrameRate
    //
    if (n.name () == "FrameRate" && n.namespace_ ().empty ())
    {
      if (!FrameRate_.present ())
      {
        this->FrameRate_.set (FrameRate_traits::create (i, f, this));
        continue;
      }
    }

    // FPtoGlobalRotations
    //
    if (n.name () == "FPtoGlobalRotations" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FPtoGlobalRotations_type > r (
        FPtoGlobalRotations_traits::create (i, f, this));

      if (!FPtoGlobalRotations_.present ())
      {
        this->FPtoGlobalRotations_.set (r);
        continue;
      }
    }

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // originGlobal
    //
    if (n.name () == "originGlobal" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< originGlobal_type > r (
        originGlobal_traits::create (i, f, this));

      if (!originGlobal_.present ())
      {
        this->originGlobal_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ID",
      "");
  }

  if (!Brand_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Brand",
      "");
  }

  if (!Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Type",
      "");
  }

  if (!FrameRate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FrameRate",
      "");
  }

  if (!FPtoGlobalRotations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FPtoGlobalRotations",
      "");
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!originGlobal_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "originGlobal",
      "");
  }
}

ForcePlatformType* ForcePlatformType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForcePlatformType (*this, f, c);
}

ForcePlatformType& ForcePlatformType::
operator= (const ForcePlatformType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->Brand_ = x.Brand_;
    this->Type_ = x.Type_;
    this->FrameRate_ = x.FrameRate_;
    this->FPtoGlobalRotations_ = x.FPtoGlobalRotations_;
    this->origin_ = x.origin_;
    this->originGlobal_ = x.originGlobal_;
  }

  return *this;
}

ForcePlatformType::
~ForcePlatformType ()
{
}

// ForcePlatformsType
//

ForcePlatformsType::
ForcePlatformsType ()
: ::xml_schema::type (),
  ForcePlatform_ (this)
{
}

ForcePlatformsType::
ForcePlatformsType (const ForcePlatformsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ForcePlatform_ (x.ForcePlatform_, f, this)
{
}

ForcePlatformsType::
ForcePlatformsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ForcePlatform_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ForcePlatformsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ForcePlatform
    //
    if (n.name () == "ForcePlatform" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ForcePlatform_type > r (
        ForcePlatform_traits::create (i, f, this));

      this->ForcePlatform_.push_back (r);
      continue;
    }

    break;
  }
}

ForcePlatformsType* ForcePlatformsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForcePlatformsType (*this, f, c);
}

ForcePlatformsType& ForcePlatformsType::
operator= (const ForcePlatformsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ForcePlatform_ = x.ForcePlatform_;
  }

  return *this;
}

ForcePlatformsType::
~ForcePlatformsType ()
{
}

// LaboratoryType
//

const LaboratoryType::Name_type LaboratoryType::Name_default_value_ (
  "required");

LaboratoryType::
LaboratoryType (const Name_type& Name,
                const MotionCaptureSystem_type& MotionCaptureSystem,
                const CoordinateSystemOrientation_type& CoordinateSystemOrientation,
                const NumberOfForcePlatforms_type& NumberOfForcePlatforms)
: ::xml_schema::type (),
  Name_ (Name, this),
  MotionCaptureSystem_ (MotionCaptureSystem, this),
  CoordinateSystemOrientation_ (CoordinateSystemOrientation, this),
  NumberOfForcePlatforms_ (NumberOfForcePlatforms, this),
  ForcePlatformsList_ (this)
{
}

LaboratoryType::
LaboratoryType (const LaboratoryType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  MotionCaptureSystem_ (x.MotionCaptureSystem_, f, this),
  CoordinateSystemOrientation_ (x.CoordinateSystemOrientation_, f, this),
  NumberOfForcePlatforms_ (x.NumberOfForcePlatforms_, f, this),
  ForcePlatformsList_ (x.ForcePlatformsList_, f, this)
{
}

LaboratoryType::
LaboratoryType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  MotionCaptureSystem_ (this),
  CoordinateSystemOrientation_ (this),
  NumberOfForcePlatforms_ (this),
  ForcePlatformsList_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LaboratoryType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!Name_.present ())
      {
        this->Name_.set (r);
        continue;
      }
    }

    // MotionCaptureSystem
    //
    if (n.name () == "MotionCaptureSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MotionCaptureSystem_type > r (
        MotionCaptureSystem_traits::create (i, f, this));

      if (!MotionCaptureSystem_.present ())
      {
        this->MotionCaptureSystem_.set (r);
        continue;
      }
    }

    // CoordinateSystemOrientation
    //
    if (n.name () == "CoordinateSystemOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CoordinateSystemOrientation_type > r (
        CoordinateSystemOrientation_traits::create (i, f, this));

      if (!CoordinateSystemOrientation_.present ())
      {
        this->CoordinateSystemOrientation_.set (r);
        continue;
      }
    }

    // NumberOfForcePlatforms
    //
    if (n.name () == "NumberOfForcePlatforms" && n.namespace_ ().empty ())
    {
      if (!NumberOfForcePlatforms_.present ())
      {
        this->NumberOfForcePlatforms_.set (NumberOfForcePlatforms_traits::create (i, f, this));
        continue;
      }
    }

    // ForcePlatformsList
    //
    if (n.name () == "ForcePlatformsList" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ForcePlatformsList_type > r (
        ForcePlatformsList_traits::create (i, f, this));

      this->ForcePlatformsList_.push_back (r);
      continue;
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!MotionCaptureSystem_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MotionCaptureSystem",
      "");
  }

  if (!CoordinateSystemOrientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CoordinateSystemOrientation",
      "");
  }

  if (!NumberOfForcePlatforms_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NumberOfForcePlatforms",
      "");
  }
}

LaboratoryType* LaboratoryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LaboratoryType (*this, f, c);
}

LaboratoryType& LaboratoryType::
operator= (const LaboratoryType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->MotionCaptureSystem_ = x.MotionCaptureSystem_;
    this->CoordinateSystemOrientation_ = x.CoordinateSystemOrientation_;
    this->NumberOfForcePlatforms_ = x.NumberOfForcePlatforms_;
    this->ForcePlatformsList_ = x.ForcePlatformsList_;
  }

  return *this;
}

LaboratoryType::
~LaboratoryType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::LaboratoryType >
Laboratory (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Laboratory (isrc, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Laboratory (isrc, h, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Laboratory (isrc, h, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Laboratory (isrc, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Laboratory (isrc, h, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Laboratory (isrc, h, f, p);
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LaboratoryType > (
    ::Laboratory (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::LaboratoryType > (
      ::Laboratory (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Laboratory" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::LaboratoryType > r (
      ::xsd::cxx::tree::traits< ::LaboratoryType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Laboratory",
    "");
}

::std::auto_ptr< ::LaboratoryType >
Laboratory (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Laboratory" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::LaboratoryType > r (
      ::xsd::cxx::tree::traits< ::LaboratoryType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Laboratory",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

