// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "executionIK_ID_V2.hxx"

// MarkerType
// 

const MarkerType::name_type& MarkerType::
name () const
{
  return this->name_.get ();
}

MarkerType::name_type& MarkerType::
name ()
{
  return this->name_.get ();
}

void MarkerType::
name (const name_type& x)
{
  this->name_.set (x);
}

void MarkerType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const MarkerType::weight_type& MarkerType::
weight () const
{
  return this->weight_.get ();
}

MarkerType::weight_type& MarkerType::
weight ()
{
  return this->weight_.get ();
}

void MarkerType::
weight (const weight_type& x)
{
  this->weight_.set (x);
}


// CoeffListIK
//

CoeffListIK::
CoeffListIK ()
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (this)
{
}

CoeffListIK::
CoeffListIK (size_type n, const ::xml_schema::double_& x)
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
{
}

CoeffListIK::
CoeffListIK (const CoeffListIK& o,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
{
}

// FilterIK
// 

const FilterIK::aCoeff_type& FilterIK::
aCoeff () const
{
  return this->aCoeff_.get ();
}

FilterIK::aCoeff_type& FilterIK::
aCoeff ()
{
  return this->aCoeff_.get ();
}

void FilterIK::
aCoeff (const aCoeff_type& x)
{
  this->aCoeff_.set (x);
}

void FilterIK::
aCoeff (::std::auto_ptr< aCoeff_type > x)
{
  this->aCoeff_.set (x);
}

const FilterIK::bCoeff_type& FilterIK::
bCoeff () const
{
  return this->bCoeff_.get ();
}

FilterIK::bCoeff_type& FilterIK::
bCoeff ()
{
  return this->bCoeff_.get ();
}

void FilterIK::
bCoeff (const bCoeff_type& x)
{
  this->bCoeff_.set (x);
}

void FilterIK::
bCoeff (::std::auto_ptr< bCoeff_type > x)
{
  this->bCoeff_.set (x);
}


// Markers
// 

const Markers::marker_sequence& Markers::
marker () const
{
  return this->marker_;
}

Markers::marker_sequence& Markers::
marker ()
{
  return this->marker_;
}

void Markers::
marker (const marker_sequence& s)
{
  this->marker_ = s;
}


// IKMarkerType
// 

const IKMarkerType::lpFilterMarker_type& IKMarkerType::
lpFilterMarker () const
{
  return this->lpFilterMarker_.get ();
}

IKMarkerType::lpFilterMarker_type& IKMarkerType::
lpFilterMarker ()
{
  return this->lpFilterMarker_.get ();
}

void IKMarkerType::
lpFilterMarker (const lpFilterMarker_type& x)
{
  this->lpFilterMarker_.set (x);
}

void IKMarkerType::
lpFilterMarker (::std::auto_ptr< lpFilterMarker_type > x)
{
  this->lpFilterMarker_.set (x);
}

const IKMarkerType::maxError_optional& IKMarkerType::
maxError () const
{
  return this->maxError_;
}

IKMarkerType::maxError_optional& IKMarkerType::
maxError ()
{
  return this->maxError_;
}

void IKMarkerType::
maxError (const maxError_type& x)
{
  this->maxError_.set (x);
}

void IKMarkerType::
maxError (const maxError_optional& x)
{
  this->maxError_ = x;
}

IKMarkerType::maxError_type IKMarkerType::
maxError_default_value ()
{
  return maxError_type (.00001);
}

const IKMarkerType::markersList_type& IKMarkerType::
markersList () const
{
  return this->markersList_.get ();
}

IKMarkerType::markersList_type& IKMarkerType::
markersList ()
{
  return this->markersList_.get ();
}

void IKMarkerType::
markersList (const markersList_type& x)
{
  this->markersList_.set (x);
}

void IKMarkerType::
markersList (::std::auto_ptr< markersList_type > x)
{
  this->markersList_.set (x);
}


// ImuType
// 

const ImuType::name_type& ImuType::
name () const
{
  return this->name_.get ();
}

ImuType::name_type& ImuType::
name ()
{
  return this->name_.get ();
}

void ImuType::
name (const name_type& x)
{
  this->name_.set (x);
}

void ImuType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const ImuType::body_type& ImuType::
body () const
{
  return this->body_.get ();
}

ImuType::body_type& ImuType::
body ()
{
  return this->body_.get ();
}

void ImuType::
body (const body_type& x)
{
  this->body_.set (x);
}

void ImuType::
body (::std::auto_ptr< body_type > x)
{
  this->body_.set (x);
}


// IKImuType
// 

const IKImuType::imu_sequence& IKImuType::
imu () const
{
  return this->imu_;
}

IKImuType::imu_sequence& IKImuType::
imu ()
{
  return this->imu_;
}

void IKImuType::
imu (const imu_sequence& s)
{
  this->imu_ = s;
}


// KalmanOptionType
// 

const KalmanOptionType::p_optional& KalmanOptionType::
p () const
{
  return this->p_;
}

KalmanOptionType::p_optional& KalmanOptionType::
p ()
{
  return this->p_;
}

void KalmanOptionType::
p (const p_type& x)
{
  this->p_.set (x);
}

void KalmanOptionType::
p (const p_optional& x)
{
  this->p_ = x;
}

KalmanOptionType::p_type KalmanOptionType::
p_default_value ()
{
  return p_type (5.0);
}

const KalmanOptionType::r_optional& KalmanOptionType::
r () const
{
  return this->r_;
}

KalmanOptionType::r_optional& KalmanOptionType::
r ()
{
  return this->r_;
}

void KalmanOptionType::
r (const r_type& x)
{
  this->r_.set (x);
}

void KalmanOptionType::
r (const r_optional& x)
{
  this->r_ = x;
}

KalmanOptionType::r_type KalmanOptionType::
r_default_value ()
{
  return r_type (.00001);
}

const KalmanOptionType::sigma_da_optional& KalmanOptionType::
sigma_da () const
{
  return this->sigma_da_;
}

KalmanOptionType::sigma_da_optional& KalmanOptionType::
sigma_da ()
{
  return this->sigma_da_;
}

void KalmanOptionType::
sigma_da (const sigma_da_type& x)
{
  this->sigma_da_.set (x);
}

void KalmanOptionType::
sigma_da (const sigma_da_optional& x)
{
  this->sigma_da_ = x;
}

KalmanOptionType::sigma_da_type KalmanOptionType::
sigma_da_default_value ()
{
  return sigma_da_type (50000.0);
}

const KalmanOptionType::dt_type& KalmanOptionType::
dt () const
{
  return this->dt_.get ();
}

KalmanOptionType::dt_type& KalmanOptionType::
dt ()
{
  return this->dt_.get ();
}

void KalmanOptionType::
dt (const dt_type& x)
{
  this->dt_.set (x);
}


// KalmanType
// 

const KalmanType::use_optional& KalmanType::
use () const
{
  return this->use_;
}

KalmanType::use_optional& KalmanType::
use ()
{
  return this->use_;
}

void KalmanType::
use (const use_type& x)
{
  this->use_.set (x);
}

void KalmanType::
use (const use_optional& x)
{
  this->use_ = x;
}

KalmanType::use_type KalmanType::
use_default_value ()
{
  return use_type (true);
}

const KalmanType::kalmanOption_type& KalmanType::
kalmanOption () const
{
  return this->kalmanOption_.get ();
}

KalmanType::kalmanOption_type& KalmanType::
kalmanOption ()
{
  return this->kalmanOption_.get ();
}

void KalmanType::
kalmanOption (const kalmanOption_type& x)
{
  this->kalmanOption_.set (x);
}

void KalmanType::
kalmanOption (::std::auto_ptr< kalmanOption_type > x)
{
  this->kalmanOption_.set (x);
}


// IKOptionType
// 

const IKOptionType::numberOfThread_optional& IKOptionType::
numberOfThread () const
{
  return this->numberOfThread_;
}

IKOptionType::numberOfThread_optional& IKOptionType::
numberOfThread ()
{
  return this->numberOfThread_;
}

void IKOptionType::
numberOfThread (const numberOfThread_type& x)
{
  this->numberOfThread_.set (x);
}

void IKOptionType::
numberOfThread (const numberOfThread_optional& x)
{
  this->numberOfThread_ = x;
}

IKOptionType::numberOfThread_type IKOptionType::
numberOfThread_default_value ()
{
  return numberOfThread_type (3LL);
}

const IKOptionType::enforceIKConstraintUse_optional& IKOptionType::
enforceIKConstraintUse () const
{
  return this->enforceIKConstraintUse_;
}

IKOptionType::enforceIKConstraintUse_optional& IKOptionType::
enforceIKConstraintUse ()
{
  return this->enforceIKConstraintUse_;
}

void IKOptionType::
enforceIKConstraintUse (const enforceIKConstraintUse_type& x)
{
  this->enforceIKConstraintUse_.set (x);
}

void IKOptionType::
enforceIKConstraintUse (const enforceIKConstraintUse_optional& x)
{
  this->enforceIKConstraintUse_ = x;
}

IKOptionType::enforceIKConstraintUse_type IKOptionType::
enforceIKConstraintUse_default_value ()
{
  return enforceIKConstraintUse_type (false);
}

const IKOptionType::kalman_type& IKOptionType::
kalman () const
{
  return this->kalman_.get ();
}

IKOptionType::kalman_type& IKOptionType::
kalman ()
{
  return this->kalman_.get ();
}

void IKOptionType::
kalman (const kalman_type& x)
{
  this->kalman_.set (x);
}

void IKOptionType::
kalman (::std::auto_ptr< kalman_type > x)
{
  this->kalman_.set (x);
}


// IKChoice
// 

const IKChoice::imus_optional& IKChoice::
imus () const
{
  return this->imus_;
}

IKChoice::imus_optional& IKChoice::
imus ()
{
  return this->imus_;
}

void IKChoice::
imus (const imus_type& x)
{
  this->imus_.set (x);
}

void IKChoice::
imus (const imus_optional& x)
{
  this->imus_ = x;
}

void IKChoice::
imus (::std::auto_ptr< imus_type > x)
{
  this->imus_.set (x);
}

const IKChoice::markers_optional& IKChoice::
markers () const
{
  return this->markers_;
}

IKChoice::markers_optional& IKChoice::
markers ()
{
  return this->markers_;
}

void IKChoice::
markers (const markers_type& x)
{
  this->markers_.set (x);
}

void IKChoice::
markers (const markers_optional& x)
{
  this->markers_ = x;
}

void IKChoice::
markers (::std::auto_ptr< markers_type > x)
{
  this->markers_.set (x);
}


// IKType
// 

const IKType::ikOption_type& IKType::
ikOption () const
{
  return this->ikOption_.get ();
}

IKType::ikOption_type& IKType::
ikOption ()
{
  return this->ikOption_.get ();
}

void IKType::
ikOption (const ikOption_type& x)
{
  this->ikOption_.set (x);
}

void IKType::
ikOption (::std::auto_ptr< ikOption_type > x)
{
  this->ikOption_.set (x);
}

const IKType::dataFrom_type& IKType::
dataFrom () const
{
  return this->dataFrom_.get ();
}

IKType::dataFrom_type& IKType::
dataFrom ()
{
  return this->dataFrom_.get ();
}

void IKType::
dataFrom (const dataFrom_type& x)
{
  this->dataFrom_.set (x);
}

void IKType::
dataFrom (::std::auto_ptr< dataFrom_type > x)
{
  this->dataFrom_.set (x);
}


// PlateForceBody
//

PlateForceBody::
PlateForceBody ()
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (this)
{
}

PlateForceBody::
PlateForceBody (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
{
}

PlateForceBody::
PlateForceBody (const PlateForceBody& o,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
{
}

// IDType
// 

const IDType::use_optional& IDType::
use () const
{
  return this->use_;
}

IDType::use_optional& IDType::
use ()
{
  return this->use_;
}

void IDType::
use (const use_type& x)
{
  this->use_.set (x);
}

void IDType::
use (const use_optional& x)
{
  this->use_ = x;
}

IDType::use_type IDType::
use_default_value ()
{
  return use_type (true);
}

const IDType::lpFilterGRF_type& IDType::
lpFilterGRF () const
{
  return this->lpFilterGRF_.get ();
}

IDType::lpFilterGRF_type& IDType::
lpFilterGRF ()
{
  return this->lpFilterGRF_.get ();
}

void IDType::
lpFilterGRF (const lpFilterGRF_type& x)
{
  this->lpFilterGRF_.set (x);
}

void IDType::
lpFilterGRF (::std::auto_ptr< lpFilterGRF_type > x)
{
  this->lpFilterGRF_.set (x);
}

const IDType::plateForceBody_type& IDType::
plateForceBody () const
{
  return this->plateForceBody_.get ();
}

IDType::plateForceBody_type& IDType::
plateForceBody ()
{
  return this->plateForceBody_.get ();
}

void IDType::
plateForceBody (const plateForceBody_type& x)
{
  this->plateForceBody_.set (x);
}

void IDType::
plateForceBody (::std::auto_ptr< plateForceBody_type > x)
{
  this->plateForceBody_.set (x);
}


// ExecutionIKType
// 

const ExecutionIKType::ik_type& ExecutionIKType::
ik () const
{
  return this->ik_.get ();
}

ExecutionIKType::ik_type& ExecutionIKType::
ik ()
{
  return this->ik_.get ();
}

void ExecutionIKType::
ik (const ik_type& x)
{
  this->ik_.set (x);
}

void ExecutionIKType::
ik (::std::auto_ptr< ik_type > x)
{
  this->ik_.set (x);
}

const ExecutionIKType::id_type& ExecutionIKType::
id () const
{
  return this->id_.get ();
}

ExecutionIKType::id_type& ExecutionIKType::
id ()
{
  return this->id_.get ();
}

void ExecutionIKType::
id (const id_type& x)
{
  this->id_.set (x);
}

void ExecutionIKType::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const ExecutionIKType::OsimFile_type& ExecutionIKType::
OsimFile () const
{
  return this->OsimFile_.get ();
}

ExecutionIKType::OsimFile_type& ExecutionIKType::
OsimFile ()
{
  return this->OsimFile_.get ();
}

void ExecutionIKType::
OsimFile (const OsimFile_type& x)
{
  this->OsimFile_.set (x);
}

void ExecutionIKType::
OsimFile (::std::auto_ptr< OsimFile_type > x)
{
  this->OsimFile_.set (x);
}

const ExecutionIKType::LabFile_type& ExecutionIKType::
LabFile () const
{
  return this->LabFile_.get ();
}

ExecutionIKType::LabFile_type& ExecutionIKType::
LabFile ()
{
  return this->LabFile_.get ();
}

void ExecutionIKType::
LabFile (const LabFile_type& x)
{
  this->LabFile_.set (x);
}

void ExecutionIKType::
LabFile (::std::auto_ptr< LabFile_type > x)
{
  this->LabFile_.set (x);
}

const ExecutionIKType::TranslateFile_type& ExecutionIKType::
TranslateFile () const
{
  return this->TranslateFile_.get ();
}

ExecutionIKType::TranslateFile_type& ExecutionIKType::
TranslateFile ()
{
  return this->TranslateFile_.get ();
}

void ExecutionIKType::
TranslateFile (const TranslateFile_type& x)
{
  this->TranslateFile_.set (x);
}

void ExecutionIKType::
TranslateFile (::std::auto_ptr< TranslateFile_type > x)
{
  this->TranslateFile_.set (x);
}

const ExecutionIKType::ip_type& ExecutionIKType::
ip () const
{
  return this->ip_.get ();
}

ExecutionIKType::ip_type& ExecutionIKType::
ip ()
{
  return this->ip_.get ();
}

void ExecutionIKType::
ip (const ip_type& x)
{
  this->ip_.set (x);
}

void ExecutionIKType::
ip (::std::auto_ptr< ip_type > x)
{
  this->ip_.set (x);
}

const ExecutionIKType::port_type& ExecutionIKType::
port () const
{
  return this->port_.get ();
}

ExecutionIKType::port_type& ExecutionIKType::
port ()
{
  return this->port_.get ();
}

void ExecutionIKType::
port (const port_type& x)
{
  this->port_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MarkerType
//

MarkerType::
MarkerType (const name_type& name,
            const weight_type& weight)
: ::xml_schema::type (),
  name_ (name, this),
  weight_ (weight, this)
{
}

MarkerType::
MarkerType (const MarkerType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  weight_ (x.weight_, f, this)
{
}

MarkerType::
MarkerType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  weight_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MarkerType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // weight
    //
    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      if (!weight_.present ())
      {
        this->weight_.set (weight_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!weight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "weight",
      "");
  }
}

MarkerType* MarkerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MarkerType (*this, f, c);
}

MarkerType& MarkerType::
operator= (const MarkerType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->weight_ = x.weight_;
  }

  return *this;
}

MarkerType::
~MarkerType ()
{
}

// CoeffListIK
//

CoeffListIK::
CoeffListIK (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
{
}

CoeffListIK::
CoeffListIK (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
{
}

CoeffListIK::
CoeffListIK (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
{
}

CoeffListIK* CoeffListIK::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CoeffListIK (*this, f, c);
}

CoeffListIK::
~CoeffListIK ()
{
}

// FilterIK
//

FilterIK::
FilterIK (const aCoeff_type& aCoeff,
          const bCoeff_type& bCoeff)
: ::xml_schema::type (),
  aCoeff_ (aCoeff, this),
  bCoeff_ (bCoeff, this)
{
}

FilterIK::
FilterIK (const FilterIK& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  aCoeff_ (x.aCoeff_, f, this),
  bCoeff_ (x.bCoeff_, f, this)
{
}

FilterIK::
FilterIK (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  aCoeff_ (this),
  bCoeff_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void FilterIK::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // aCoeff
    //
    if (n.name () == "aCoeff" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< aCoeff_type > r (
        aCoeff_traits::create (i, f, this));

      if (!aCoeff_.present ())
      {
        this->aCoeff_.set (r);
        continue;
      }
    }

    // bCoeff
    //
    if (n.name () == "bCoeff" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bCoeff_type > r (
        bCoeff_traits::create (i, f, this));

      if (!bCoeff_.present ())
      {
        this->bCoeff_.set (r);
        continue;
      }
    }

    break;
  }

  if (!aCoeff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "aCoeff",
      "");
  }

  if (!bCoeff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bCoeff",
      "");
  }
}

FilterIK* FilterIK::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FilterIK (*this, f, c);
}

FilterIK& FilterIK::
operator= (const FilterIK& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->aCoeff_ = x.aCoeff_;
    this->bCoeff_ = x.bCoeff_;
  }

  return *this;
}

FilterIK::
~FilterIK ()
{
}

// Markers
//

Markers::
Markers ()
: ::xml_schema::type (),
  marker_ (this)
{
}

Markers::
Markers (const Markers& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  marker_ (x.marker_, f, this)
{
}

Markers::
Markers (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  marker_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Markers::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // marker
    //
    if (n.name () == "marker" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marker_type > r (
        marker_traits::create (i, f, this));

      this->marker_.push_back (r);
      continue;
    }

    break;
  }
}

Markers* Markers::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Markers (*this, f, c);
}

Markers& Markers::
operator= (const Markers& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->marker_ = x.marker_;
  }

  return *this;
}

Markers::
~Markers ()
{
}

// IKMarkerType
//

IKMarkerType::
IKMarkerType (const lpFilterMarker_type& lpFilterMarker,
              const markersList_type& markersList)
: ::xml_schema::type (),
  lpFilterMarker_ (lpFilterMarker, this),
  maxError_ (this),
  markersList_ (markersList, this)
{
}

IKMarkerType::
IKMarkerType (::std::auto_ptr< lpFilterMarker_type > lpFilterMarker,
              ::std::auto_ptr< markersList_type > markersList)
: ::xml_schema::type (),
  lpFilterMarker_ (lpFilterMarker, this),
  maxError_ (this),
  markersList_ (markersList, this)
{
}

IKMarkerType::
IKMarkerType (const IKMarkerType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lpFilterMarker_ (x.lpFilterMarker_, f, this),
  maxError_ (x.maxError_, f, this),
  markersList_ (x.markersList_, f, this)
{
}

IKMarkerType::
IKMarkerType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lpFilterMarker_ (this),
  maxError_ (this),
  markersList_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IKMarkerType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lpFilterMarker
    //
    if (n.name () == "lpFilterMarker" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lpFilterMarker_type > r (
        lpFilterMarker_traits::create (i, f, this));

      if (!lpFilterMarker_.present ())
      {
        this->lpFilterMarker_.set (r);
        continue;
      }
    }

    // maxError
    //
    if (n.name () == "maxError" && n.namespace_ ().empty ())
    {
      if (!this->maxError_)
      {
        this->maxError_.set (maxError_traits::create (i, f, this));
        continue;
      }
    }

    // markersList
    //
    if (n.name () == "markersList" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< markersList_type > r (
        markersList_traits::create (i, f, this));

      if (!markersList_.present ())
      {
        this->markersList_.set (r);
        continue;
      }
    }

    break;
  }

  if (!lpFilterMarker_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lpFilterMarker",
      "");
  }

  if (!markersList_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "markersList",
      "");
  }
}

IKMarkerType* IKMarkerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IKMarkerType (*this, f, c);
}

IKMarkerType& IKMarkerType::
operator= (const IKMarkerType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lpFilterMarker_ = x.lpFilterMarker_;
    this->maxError_ = x.maxError_;
    this->markersList_ = x.markersList_;
  }

  return *this;
}

IKMarkerType::
~IKMarkerType ()
{
}

// ImuType
//

ImuType::
ImuType (const name_type& name,
         const body_type& body)
: ::xml_schema::type (),
  name_ (name, this),
  body_ (body, this)
{
}

ImuType::
ImuType (const ImuType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  body_ (x.body_, f, this)
{
}

ImuType::
ImuType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  body_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ImuType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // body
    //
    if (n.name () == "body" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< body_type > r (
        body_traits::create (i, f, this));

      if (!body_.present ())
      {
        this->body_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!body_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "body",
      "");
  }
}

ImuType* ImuType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ImuType (*this, f, c);
}

ImuType& ImuType::
operator= (const ImuType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->body_ = x.body_;
  }

  return *this;
}

ImuType::
~ImuType ()
{
}

// IKImuType
//

IKImuType::
IKImuType ()
: ::xml_schema::type (),
  imu_ (this)
{
}

IKImuType::
IKImuType (const IKImuType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  imu_ (x.imu_, f, this)
{
}

IKImuType::
IKImuType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  imu_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IKImuType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // imu
    //
    if (n.name () == "imu" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< imu_type > r (
        imu_traits::create (i, f, this));

      this->imu_.push_back (r);
      continue;
    }

    break;
  }
}

IKImuType* IKImuType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IKImuType (*this, f, c);
}

IKImuType& IKImuType::
operator= (const IKImuType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->imu_ = x.imu_;
  }

  return *this;
}

IKImuType::
~IKImuType ()
{
}

// KalmanOptionType
//

KalmanOptionType::
KalmanOptionType (const dt_type& dt)
: ::xml_schema::type (),
  p_ (this),
  r_ (this),
  sigma_da_ (this),
  dt_ (dt, this)
{
}

KalmanOptionType::
KalmanOptionType (const KalmanOptionType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  p_ (x.p_, f, this),
  r_ (x.r_, f, this),
  sigma_da_ (x.sigma_da_, f, this),
  dt_ (x.dt_, f, this)
{
}

KalmanOptionType::
KalmanOptionType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  p_ (this),
  r_ (this),
  sigma_da_ (this),
  dt_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void KalmanOptionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // p
    //
    if (n.name () == "p" && n.namespace_ ().empty ())
    {
      if (!this->p_)
      {
        this->p_.set (p_traits::create (i, f, this));
        continue;
      }
    }

    // r
    //
    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      if (!this->r_)
      {
        this->r_.set (r_traits::create (i, f, this));
        continue;
      }
    }

    // sigma_da
    //
    if (n.name () == "sigma_da" && n.namespace_ ().empty ())
    {
      if (!this->sigma_da_)
      {
        this->sigma_da_.set (sigma_da_traits::create (i, f, this));
        continue;
      }
    }

    // dt
    //
    if (n.name () == "dt" && n.namespace_ ().empty ())
    {
      if (!dt_.present ())
      {
        this->dt_.set (dt_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!dt_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dt",
      "");
  }
}

KalmanOptionType* KalmanOptionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class KalmanOptionType (*this, f, c);
}

KalmanOptionType& KalmanOptionType::
operator= (const KalmanOptionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->p_ = x.p_;
    this->r_ = x.r_;
    this->sigma_da_ = x.sigma_da_;
    this->dt_ = x.dt_;
  }

  return *this;
}

KalmanOptionType::
~KalmanOptionType ()
{
}

// KalmanType
//

KalmanType::
KalmanType (const kalmanOption_type& kalmanOption)
: ::xml_schema::type (),
  use_ (this),
  kalmanOption_ (kalmanOption, this)
{
}

KalmanType::
KalmanType (::std::auto_ptr< kalmanOption_type > kalmanOption)
: ::xml_schema::type (),
  use_ (this),
  kalmanOption_ (kalmanOption, this)
{
}

KalmanType::
KalmanType (const KalmanType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  use_ (x.use_, f, this),
  kalmanOption_ (x.kalmanOption_, f, this)
{
}

KalmanType::
KalmanType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  use_ (this),
  kalmanOption_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void KalmanType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // use
    //
    if (n.name () == "use" && n.namespace_ ().empty ())
    {
      if (!this->use_)
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    // kalmanOption
    //
    if (n.name () == "kalmanOption" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< kalmanOption_type > r (
        kalmanOption_traits::create (i, f, this));

      if (!kalmanOption_.present ())
      {
        this->kalmanOption_.set (r);
        continue;
      }
    }

    break;
  }

  if (!kalmanOption_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "kalmanOption",
      "");
  }
}

KalmanType* KalmanType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class KalmanType (*this, f, c);
}

KalmanType& KalmanType::
operator= (const KalmanType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->use_ = x.use_;
    this->kalmanOption_ = x.kalmanOption_;
  }

  return *this;
}

KalmanType::
~KalmanType ()
{
}

// IKOptionType
//

IKOptionType::
IKOptionType (const kalman_type& kalman)
: ::xml_schema::type (),
  numberOfThread_ (this),
  enforceIKConstraintUse_ (this),
  kalman_ (kalman, this)
{
}

IKOptionType::
IKOptionType (::std::auto_ptr< kalman_type > kalman)
: ::xml_schema::type (),
  numberOfThread_ (this),
  enforceIKConstraintUse_ (this),
  kalman_ (kalman, this)
{
}

IKOptionType::
IKOptionType (const IKOptionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numberOfThread_ (x.numberOfThread_, f, this),
  enforceIKConstraintUse_ (x.enforceIKConstraintUse_, f, this),
  kalman_ (x.kalman_, f, this)
{
}

IKOptionType::
IKOptionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numberOfThread_ (this),
  enforceIKConstraintUse_ (this),
  kalman_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IKOptionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // numberOfThread
    //
    if (n.name () == "numberOfThread" && n.namespace_ ().empty ())
    {
      if (!this->numberOfThread_)
      {
        this->numberOfThread_.set (numberOfThread_traits::create (i, f, this));
        continue;
      }
    }

    // enforceIKConstraintUse
    //
    if (n.name () == "enforceIKConstraintUse" && n.namespace_ ().empty ())
    {
      if (!this->enforceIKConstraintUse_)
      {
        this->enforceIKConstraintUse_.set (enforceIKConstraintUse_traits::create (i, f, this));
        continue;
      }
    }

    // kalman
    //
    if (n.name () == "kalman" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< kalman_type > r (
        kalman_traits::create (i, f, this));

      if (!kalman_.present ())
      {
        this->kalman_.set (r);
        continue;
      }
    }

    break;
  }

  if (!kalman_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "kalman",
      "");
  }
}

IKOptionType* IKOptionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IKOptionType (*this, f, c);
}

IKOptionType& IKOptionType::
operator= (const IKOptionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->numberOfThread_ = x.numberOfThread_;
    this->enforceIKConstraintUse_ = x.enforceIKConstraintUse_;
    this->kalman_ = x.kalman_;
  }

  return *this;
}

IKOptionType::
~IKOptionType ()
{
}

// IKChoice
//

IKChoice::
IKChoice ()
: ::xml_schema::type (),
  imus_ (this),
  markers_ (this)
{
}

IKChoice::
IKChoice (const IKChoice& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  imus_ (x.imus_, f, this),
  markers_ (x.markers_, f, this)
{
}

IKChoice::
IKChoice (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  imus_ (this),
  markers_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IKChoice::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // imus
    //
    if (n.name () == "imus" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< imus_type > r (
        imus_traits::create (i, f, this));

      if (!this->imus_)
      {
        this->imus_.set (r);
        continue;
      }
    }

    // markers
    //
    if (n.name () == "markers" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< markers_type > r (
        markers_traits::create (i, f, this));

      if (!this->markers_)
      {
        this->markers_.set (r);
        continue;
      }
    }

    break;
  }
}

IKChoice* IKChoice::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IKChoice (*this, f, c);
}

IKChoice& IKChoice::
operator= (const IKChoice& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->imus_ = x.imus_;
    this->markers_ = x.markers_;
  }

  return *this;
}

IKChoice::
~IKChoice ()
{
}

// IKType
//

IKType::
IKType (const ikOption_type& ikOption,
        const dataFrom_type& dataFrom)
: ::xml_schema::type (),
  ikOption_ (ikOption, this),
  dataFrom_ (dataFrom, this)
{
}

IKType::
IKType (::std::auto_ptr< ikOption_type > ikOption,
        ::std::auto_ptr< dataFrom_type > dataFrom)
: ::xml_schema::type (),
  ikOption_ (ikOption, this),
  dataFrom_ (dataFrom, this)
{
}

IKType::
IKType (const IKType& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ikOption_ (x.ikOption_, f, this),
  dataFrom_ (x.dataFrom_, f, this)
{
}

IKType::
IKType (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ikOption_ (this),
  dataFrom_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IKType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ikOption
    //
    if (n.name () == "ikOption" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ikOption_type > r (
        ikOption_traits::create (i, f, this));

      if (!ikOption_.present ())
      {
        this->ikOption_.set (r);
        continue;
      }
    }

    // dataFrom
    //
    if (n.name () == "dataFrom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataFrom_type > r (
        dataFrom_traits::create (i, f, this));

      if (!dataFrom_.present ())
      {
        this->dataFrom_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ikOption_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ikOption",
      "");
  }

  if (!dataFrom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dataFrom",
      "");
  }
}

IKType* IKType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IKType (*this, f, c);
}

IKType& IKType::
operator= (const IKType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ikOption_ = x.ikOption_;
    this->dataFrom_ = x.dataFrom_;
  }

  return *this;
}

IKType::
~IKType ()
{
}

// PlateForceBody
//

PlateForceBody::
PlateForceBody (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
{
}

PlateForceBody::
PlateForceBody (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
{
}

PlateForceBody::
PlateForceBody (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
{
}

PlateForceBody* PlateForceBody::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PlateForceBody (*this, f, c);
}

PlateForceBody::
~PlateForceBody ()
{
}

// IDType
//

IDType::
IDType (const lpFilterGRF_type& lpFilterGRF,
        const plateForceBody_type& plateForceBody)
: ::xml_schema::type (),
  use_ (this),
  lpFilterGRF_ (lpFilterGRF, this),
  plateForceBody_ (plateForceBody, this)
{
}

IDType::
IDType (::std::auto_ptr< lpFilterGRF_type > lpFilterGRF,
        const plateForceBody_type& plateForceBody)
: ::xml_schema::type (),
  use_ (this),
  lpFilterGRF_ (lpFilterGRF, this),
  plateForceBody_ (plateForceBody, this)
{
}

IDType::
IDType (const IDType& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  use_ (x.use_, f, this),
  lpFilterGRF_ (x.lpFilterGRF_, f, this),
  plateForceBody_ (x.plateForceBody_, f, this)
{
}

IDType::
IDType (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  use_ (this),
  lpFilterGRF_ (this),
  plateForceBody_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IDType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // use
    //
    if (n.name () == "use" && n.namespace_ ().empty ())
    {
      if (!this->use_)
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    // lpFilterGRF
    //
    if (n.name () == "lpFilterGRF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lpFilterGRF_type > r (
        lpFilterGRF_traits::create (i, f, this));

      if (!lpFilterGRF_.present ())
      {
        this->lpFilterGRF_.set (r);
        continue;
      }
    }

    // plateForceBody
    //
    if (n.name () == "plateForceBody" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< plateForceBody_type > r (
        plateForceBody_traits::create (i, f, this));

      if (!plateForceBody_.present ())
      {
        this->plateForceBody_.set (r);
        continue;
      }
    }

    break;
  }

  if (!lpFilterGRF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lpFilterGRF",
      "");
  }

  if (!plateForceBody_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "plateForceBody",
      "");
  }
}

IDType* IDType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IDType (*this, f, c);
}

IDType& IDType::
operator= (const IDType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->use_ = x.use_;
    this->lpFilterGRF_ = x.lpFilterGRF_;
    this->plateForceBody_ = x.plateForceBody_;
  }

  return *this;
}

IDType::
~IDType ()
{
}

// ExecutionIKType
//

ExecutionIKType::
ExecutionIKType (const ik_type& ik,
                 const id_type& id,
                 const OsimFile_type& OsimFile,
                 const LabFile_type& LabFile,
                 const TranslateFile_type& TranslateFile,
                 const ip_type& ip,
                 const port_type& port)
: ::xml_schema::type (),
  ik_ (ik, this),
  id_ (id, this),
  OsimFile_ (OsimFile, this),
  LabFile_ (LabFile, this),
  TranslateFile_ (TranslateFile, this),
  ip_ (ip, this),
  port_ (port, this)
{
}

ExecutionIKType::
ExecutionIKType (::std::auto_ptr< ik_type > ik,
                 ::std::auto_ptr< id_type > id,
                 const OsimFile_type& OsimFile,
                 const LabFile_type& LabFile,
                 const TranslateFile_type& TranslateFile,
                 const ip_type& ip,
                 const port_type& port)
: ::xml_schema::type (),
  ik_ (ik, this),
  id_ (id, this),
  OsimFile_ (OsimFile, this),
  LabFile_ (LabFile, this),
  TranslateFile_ (TranslateFile, this),
  ip_ (ip, this),
  port_ (port, this)
{
}

ExecutionIKType::
ExecutionIKType (const ExecutionIKType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ik_ (x.ik_, f, this),
  id_ (x.id_, f, this),
  OsimFile_ (x.OsimFile_, f, this),
  LabFile_ (x.LabFile_, f, this),
  TranslateFile_ (x.TranslateFile_, f, this),
  ip_ (x.ip_, f, this),
  port_ (x.port_, f, this)
{
}

ExecutionIKType::
ExecutionIKType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ik_ (this),
  id_ (this),
  OsimFile_ (this),
  LabFile_ (this),
  TranslateFile_ (this),
  ip_ (this),
  port_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ExecutionIKType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ik
    //
    if (n.name () == "ik" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ik_type > r (
        ik_traits::create (i, f, this));

      if (!ik_.present ())
      {
        this->ik_.set (r);
        continue;
      }
    }

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< id_type > r (
        id_traits::create (i, f, this));

      if (!id_.present ())
      {
        this->id_.set (r);
        continue;
      }
    }

    // OsimFile
    //
    if (n.name () == "OsimFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OsimFile_type > r (
        OsimFile_traits::create (i, f, this));

      if (!OsimFile_.present ())
      {
        this->OsimFile_.set (r);
        continue;
      }
    }

    // LabFile
    //
    if (n.name () == "LabFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LabFile_type > r (
        LabFile_traits::create (i, f, this));

      if (!LabFile_.present ())
      {
        this->LabFile_.set (r);
        continue;
      }
    }

    // TranslateFile
    //
    if (n.name () == "TranslateFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TranslateFile_type > r (
        TranslateFile_traits::create (i, f, this));

      if (!TranslateFile_.present ())
      {
        this->TranslateFile_.set (r);
        continue;
      }
    }

    // ip
    //
    if (n.name () == "ip" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ip_type > r (
        ip_traits::create (i, f, this));

      if (!ip_.present ())
      {
        this->ip_.set (r);
        continue;
      }
    }

    // port
    //
    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      if (!port_.present ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!ik_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ik",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!OsimFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "OsimFile",
      "");
  }

  if (!LabFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LabFile",
      "");
  }

  if (!TranslateFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TranslateFile",
      "");
  }

  if (!ip_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ip",
      "");
  }

  if (!port_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "port",
      "");
  }
}

ExecutionIKType* ExecutionIKType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ExecutionIKType (*this, f, c);
}

ExecutionIKType& ExecutionIKType::
operator= (const ExecutionIKType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ik_ = x.ik_;
    this->id_ = x.id_;
    this->OsimFile_ = x.OsimFile_;
    this->LabFile_ = x.LabFile_;
    this->TranslateFile_ = x.TranslateFile_;
    this->ip_ = x.ip_;
    this->port_ = x.port_;
  }

  return *this;
}

ExecutionIKType::
~ExecutionIKType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::ExecutionIKType >
executionIK (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::executionIK (isrc, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::executionIK (isrc, h, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::executionIK (isrc, h, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::executionIK (isrc, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::executionIK (isrc, h, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::executionIK (isrc, h, f, p);
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ExecutionIKType > (
    ::executionIK (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ExecutionIKType > (
      ::executionIK (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "executionIK" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ExecutionIKType > r (
      ::xsd::cxx::tree::traits< ::ExecutionIKType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "executionIK",
    "");
}

::std::auto_ptr< ::ExecutionIKType >
executionIK (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "executionIK" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ExecutionIKType > r (
      ::xsd::cxx::tree::traits< ::ExecutionIKType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "executionIK",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

